<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é»ƒé‡‘ç¤¦å·¥ RPG: å‚³èªªçµäºº</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            touch-action: none;
            user-select: none;
        }

        #game-wrapper {
            position: relative;
            box-shadow: 0 0 60px rgba(0,0,0,1);
            border: 4px solid #3e2723;
            border-radius: 8px;
            width: 800px;
            height: 600px;
            background: #111;
            display: flex;
        }

        /* å·¦å´è³‡è¨Šæ¬„ */
        #sidebar {
            width: 180px;
            background: #1a1a1a;
            border-right: 2px solid #3e2723;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            color: #ddd;
            font-size: 14px;
        }

        #sidebar h3 {
            color: #f1c40f;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
            margin-top: 0;
            text-align: center;
        }

        .info-card {
            background: #222;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 8px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .info-icon { font-size: 28px; width: 40px; text-align: center; display: block; }
        .info-details { flex: 1; }
        .info-name { font-weight: bold; color: #fff; font-size: 13px; }
        .info-val { color: #2ecc71; font-size: 12px; }
        .info-effect { color: #e67e22; font-size: 11px; margin-top: 2px; }

        canvas {
            display: block;
            background: #111;
        }

        /* UI å±¤ */
        #ui-layer {
            position: absolute;
            top: 15px;
            left: 195px; /* Offset by sidebar */
            right: 15px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            font-size: 20px;
            z-index: 5;
        }

        .ui-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            border: 2px solid #5d4037;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        }
        
        .highlight { color: #f1c40f; font-weight: bold; margin-left: 5px; }
        .hook-count { color: #3498db; font-weight: bold; margin-left: 5px; }

        /* é€šçŸ¥èˆ‡ç‰¹æ•ˆ */
        #notification-area {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 220px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
            z-index: 6;
        }

        .notif {
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
            border-left: 4px solid #fff;
            animation: fadeOut 3s forwards;
            line-height: 1.4;
            white-space: pre-wrap;
        }
        .notif-poison { border-left-color: #2ecc71; }
        .notif-bleed { border-left-color: #e74c3c; }
        .notif-turn { border-left-color: #3498db; font-weight: bold; }
        .notif-hit { border-left-color: #f1c40f; box-shadow: 0 0 10px rgba(241, 196, 15, 0.3); }
        .notif-miss { border-left-color: #7f8c8d; color: #aaa; }
        .notif-crit { border-left-color: #ff0000; box-shadow: 0 0 15px rgba(255, 0, 0, 0.5); font-weight: bold; color: #ffcccc; }

        @keyframes fadeOut {
            0% { opacity: 0; transform: translateX(20px); }
            10% { opacity: 1; transform: translateX(0); }
            85% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* è¦†è“‹ç•«é¢ */
        .overlay-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 10, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        /* ç¤¦ç‰©ç™¼ç¾å½ˆçª— */
        #discovery-popup {
            background: rgba(20, 20, 20, 0.98);
            border: 2px solid #f1c40f;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 0 50px rgba(241, 196, 15, 0.2);
            z-index: 30;
        }
        .disco-icon { font-size: 80px; margin: 20px 0; display: block; }
        .disco-stats { color: #2ecc71; font-size: 24px; font-weight: bold; margin: 10px 0; }

        .card-container { display: flex; gap: 20px; margin-top: 30px; }
        .card {
            width: 200px; height: 320px; background: #222;
            border: 2px solid #555; border-radius: 10px; padding: 15px;
            display: flex; flex-direction: column; align-items: center;
            text-align: center; cursor: pointer; position: relative;
            transition: transform 0.2s;
        }
        .card:hover { transform: translateY(-10px); border-color: #f1c40f; }
        .card-mineral { border-color: #3498db; background: linear-gradient(180deg, #1a2a3a, #000); }
        .card-hook { border-color: #e67e22; background: linear-gradient(180deg, #3a2a1a, #000); }
        .card-legendary { border-color: #f1c40f; background: linear-gradient(180deg, #3a3a1a, #2c0000); box-shadow: 0 0 15px rgba(241, 196, 15, 0.3); }

        .card-icon { font-size: 48px; margin-bottom: 15px; }
        .card-title { font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 10px; }
        .card-desc { font-size: 14px; color: #ccc; line-height: 1.4; }
        .card-type { position: absolute; bottom: 10px; font-size: 12px; opacity: 0.6; text-transform: uppercase; }

        .btn {
            padding: 12px 30px; font-size: 20px;
            background: #c0392b; color: white;
            border: none; border-radius: 5px; cursor: pointer; margin-top: 20px;
        }
        .hidden { display: none !important; }

        /* Boss è¡€æ¢å®¹å™¨ */
        #boss-hp-container {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-40%); /* Adjusted for sidebar */
            width: 500px; height: 24px; background: #111;
            border: 2px solid #555; border-radius: 12px; display: none; overflow: hidden;
        }
        #boss-hp-fill { width: 100%; height: 100%; background: #c0392b; transition: width 0.2s; }
        #boss-name { position: absolute; top: -25px; left: 0; width: 100%; text-align: center; color: #e74c3c; font-weight: bold; text-shadow: 1px 1px 0 #000; }

    </style>
</head>
<body>

<div id="game-wrapper">
    <!-- å·¦å´åœ–é‘‘ -->
    <div id="sidebar">
        <h3>æœ¬é—œç¤¦ç‰©</h3>
        <div id="mineral-list">
            <!-- JS æ³¨å…¥ -->
        </div>
    </div>

    <div style="position: relative; flex: 1;">
        <canvas id="gameCanvas" width="620" height="600"></canvas> <!-- å¯¬åº¦æ¸›å» Sidebar -->
        
        <!-- UI -->
        <div id="ui-layer">
            <div class="ui-box">åˆ†æ•¸: <span id="score" class="highlight">0</span></div>
            <div class="ui-box">é—œå¡: <span id="level" class="highlight">1</span></div>
            <div class="ui-box" style="border-color: #3498db;">æ›é‰¤: <span id="hooks" class="hook-count">10/10</span></div>
        </div>

        <!-- Boss UI -->
        <div id="boss-hp-container">
            <div id="boss-name">BOSS</div>
            <div id="boss-hp-fill"></div>
        </div>

        <div id="notification-area"></div>

        <!-- æ–°ç¤¦ç‰©ç™¼ç¾å½ˆçª— -->
        <div id="discovery-screen" class="overlay-screen hidden">
            <div id="discovery-popup">
                <h2 style="color: #3498db; margin: 0;">æ–°ç¤¦ç‰©åœ–é‘‘è§£é–ï¼</h2>
                <div id="disco-icon" class="disco-icon">ğŸ’</div>
                <h3 id="disco-name" style="font-size: 32px; margin: 0;">é‘½çŸ³</h3>
                <div id="disco-stats" class="disco-stats">æ”»æ“ŠåŠ›: 2000</div>
                <p id="disco-desc" style="color: #ccc;">ç¨€æœ‰ä¸”å …ç¡¬çš„å¯¶çŸ³ï¼Œèƒ½é€ æˆæ¯€æ»…æ€§çš„å‚·å®³ã€‚</p>
                <button class="btn" onclick="game.closeDiscovery()">ç¢ºèª</button>
            </div>
        </div>

        <!-- ç•«é¢: é–‹å§‹ -->
        <div id="start-screen" class="overlay-screen">
            <h1 style="color: #f1c40f; font-size: 42px; margin-bottom: 10px;">é»ƒé‡‘ç¤¦å·¥ Rogue</h1>
            <h2 style="color: #ccc; font-size: 20px;">å›åˆåˆ¶æˆ°ç•¥ç‰ˆ</h2>
            <div style="text-align: center; max-width: 500px; line-height: 1.6; color: #aaa; margin: 20px;">
                <p>æ¯æ¬¡å‡ºé‰¤è¦–ç‚º<span style="color:#e74c3c">ä¸€å›åˆ</span>ã€‚</p>
                <p>æ™®é€šæ”»æ“Šç‚ºå–®é«”ï¼Œ<span style="color:#f1c40f">çˆ†æ“Š</span>æ‰æœƒè§¸ç™¼<span style="color:#f1c40f">å…¨é«”å‚·å®³</span>ã€‚</p>
                <p>ç‹€æ…‹æ•ˆæœ(ä¸­æ¯’/æµè¡€)æœƒç–ŠåŠ å±¤æ•¸ï¼Œ<br>æ¯å›åˆé€ æˆå‚·å®³å¾Œå±¤æ•¸éæ¸›ã€‚</p>
                <p>æ”¶é›†å¡ç‰Œï¼šå¯å°‡ç¤¦ç‰©<span style="color:#3498db">è®Šå¤§/è®Šå°</span>æˆ–<span style="color:#3498db">æ§åˆ¶å‡ºç¾ç‡</span>ã€‚</p>
            </div>
            <button class="btn" onclick="game.start()">é–‹å§‹å†’éšª</button>
        </div>

        <!-- ç•«é¢: çå‹µé¸æ“‡ -->
        <div id="reward-screen" class="overlay-screen hidden">
            <h2 id="reward-title" style="color: #f1c40f; margin-bottom: 10px;">æˆ°åˆ©å“é¸æ“‡</h2>
            <p id="reward-subtitle" style="color: #aaa;">åªèƒ½é¸æ“‡ä¸€å¼µ</p>
            <div id="card-container" class="card-container"></div>
        </div>

        <!-- ç•«é¢: éŠæˆ²çµæŸ -->
        <div id="game-over-screen" class="overlay-screen hidden">
            <h1 style="color: #e74c3c;">ç‹©çµçµæŸ</h1>
            <p id="end-reason" style="margin: 10px 0; font-size: 20px;">æ›é‰¤è€—ç›¡</p>
            <p id="final-score" style="font-size: 24px; color: #f1c40f; margin-bottom: 30px;">æœ€çµ‚åˆ†æ•¸: 0</p>
            <button class="btn" onclick="game.start()">é‡æ–°é–‹å§‹</button>
        </div>
    </div>
</div>

<script>
    /* ================= è³‡æ–™è¨­å®š ================= */
    const MINERALS = {
        ROCK:    { name: 'å²©çŸ³', val: 100, weight: 5.0, radius: 35, icon: 'ğŸª¨', unlockLv: 1, desc: 'æ™®é€šçš„çŸ³é ­ï¼Œå‚·å®³ä½ä½†éš¨è™•å¯è¦‹ã€‚' },
        COPPER:  { name: 'éŠ…ç¤¦', val: 300, weight: 2.0, radius: 20, icon: 'ğŸŸ ', unlockLv: 1, desc: 'åŸºç¤çš„é‡‘å±¬ç¤¦ç‰©ï¼Œé‡é‡è¼•ï¼Œé©åˆå¿«é€Ÿæ”»æ“Šã€‚' },
        SILVER:  { name: 'ç™½éŠ€', val: 500, weight: 2.5, radius: 22, icon: 'âšª', unlockLv: 2, desc: 'æ¯”éŠ…ç¤¦æ›´æœ‰åƒ¹å€¼çš„é‡‘å±¬ã€‚' },
        IRON:    { name: 'éµç¤¦', val: 200, weight: 3.5, radius: 24, icon: 'ğŸ›¡ï¸', unlockLv: 3, desc: 'å …ç¡¬çš„éµç¤¦ï¼Œé›–ç„¶ä¸è²´ä½†å¾ˆæœ‰ä»½é‡ã€‚' },
        GOLD:    { name: 'é»ƒé‡‘', val: 1000, weight: 4.0, radius: 25, icon: 'ğŸŸ¡', unlockLv: 4, desc: 'é–ƒè€€çš„é»ƒé‡‘ï¼Œèƒ½é€ æˆå¯è§€çš„å‚·å®³ã€‚' },
        RUBY:    { name: 'ç´…å¯¶çŸ³', val: 1500, weight: 1.2, radius: 12, icon: 'ğŸ”º', unlockLv: 6, desc: 'è˜Šå«ç«ç„°åŠ›é‡çš„å¯¶çŸ³ã€‚' },
        EMERALD: { name: 'ç¥–æ¯ç¶ ', val: 1200, weight: 1.3, radius: 14, icon: 'ğŸŸ©', unlockLv: 8, desc: 'å¸¶æœ‰è‡ªç„¶æ¯’ç´ çš„ç¶ è‰²å¯¶çŸ³ã€‚' },
        DIAMOND: { name: 'é‘½çŸ³', val: 2500, weight: 0.8, radius: 10, icon: 'ğŸ’', unlockLv: 10, desc: 'æœ€å …ç¡¬çš„ç‰©è³ªï¼Œå‚·å®³æ¥µé«˜ä¸”é€Ÿåº¦å¿«ã€‚' }
    };

    const CONFIG = {
        width: 620, height: 600, groundY: 120, 
        baseSwingSpeed: 0.02, baseShootSpeed: 8, baseRetractSpeed: 12
    };

    /* ================= ç³»çµ±é¡åˆ¥ ================= */
    
    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.state = 'MENU';
            
            this.score = 0;
            this.level = 1;
            this.discoveredMinerals = new Set();
            this.newDiscoveryQueue = []; // Queue for popups
            
            this.maxHookCount = 10;
            this.currentHooks = 10;
            
            this.buffs = {
                mineralDmg: {},    
                mineralEffect: {}, 
                spawnRates: {}, 
                mineralSize: {}, 
                extraMineralCount: 0, 
                hookSize: 1.0,
                hookSpeed: 1.0,
                doubleHook: false, 
                freeHookChance: 0.0,
                critChance: 0.15
            };

            this.entities = { items: [], monsters: [], damageTexts: [] };
            this.hooks = [];
            this.lastTime = 0;
            this.turnAction = null; 
            
            this.bossEffectTimer = 0;
        }

        start() {
            this.score = 0;
            this.level = 1;
            this.currentHooks = 10;
            this.maxHookCount = 10;
            this.discoveredMinerals.clear();
            
            this.buffs = {
                mineralDmg: {}, mineralEffect: {}, spawnRates: {}, mineralSize: {},
                extraMineralCount: 0,
                hookSize: 1.0, hookSpeed: 1.0,
                doubleHook: false, freeHookChance: 0.0,
                critChance: 0.15
            };

            // Init spawn rates
            Object.keys(MINERALS).forEach(k => {
                this.buffs.spawnRates[k] = 1;
                this.buffs.mineralSize[k] = 1;
            });

            // Pre-discover level 1 basics
            this.discoveredMinerals.add('ROCK');
            this.discoveredMinerals.add('COPPER');

            this.prepareLevel();
            this.loop = this.loop.bind(this);
            requestAnimationFrame(this.loop);
        }

        prepareLevel() {
            document.querySelectorAll('.overlay-screen').forEach(el => el.classList.add('hidden'));
            
            this.currentHooks = this.maxHookCount;
            this.updateUI();
            this.bossEffectTimer = 0;
            
            this.hooks = [new Hook(CONFIG.width/2, 70)]; 
            this.generateLevelData();
            this.updateSidebar();

            // Check for new minerals
            const currentLevelMinerals = this.entities.items.map(i => i.type);
            const uniqueTypes = [...new Set(currentLevelMinerals)];
            
            this.newDiscoveryQueue = uniqueTypes.filter(t => !this.discoveredMinerals.has(t));
            
            if (this.newDiscoveryQueue.length > 0) {
                this.showNextDiscovery();
            } else {
                this.state = 'PLAYING';
            }
        }

        showNextDiscovery() {
            if (this.newDiscoveryQueue.length === 0) {
                document.getElementById('discovery-screen').classList.add('hidden');
                this.state = 'PLAYING';
                return;
            }

            const type = this.newDiscoveryQueue.shift();
            this.discoveredMinerals.add(type);
            const data = MINERALS[type];

            document.getElementById('discovery-screen').classList.remove('hidden');
            document.getElementById('disco-icon').innerText = data.icon;
            document.getElementById('disco-name').innerText = data.name;
            document.getElementById('disco-stats').innerText = `æ”»æ“ŠåŠ›: ${data.val}`;
            document.getElementById('disco-desc').innerText = data.desc;
        }

        closeDiscovery() {
            this.showNextDiscovery();
        }

        generateLevelData() {
            this.entities.items = [];
            this.entities.monsters = [];
            this.entities.damageTexts = [];

            const isBoss = (this.level % 5 === 0);
            
            // Boss ç‰¹æ•ˆ Trigger
            if (isBoss) {
                this.bossEffectTimer = 180; // 3 seconds at 60fps
            }

            // ç”Ÿæˆç¤¦ç‰©
            const availableTypes = Object.keys(MINERALS).filter(k => MINERALS[k].unlockLv <= this.level);
            const count = 12 + Math.min(this.level, 8) + this.buffs.extraMineralCount;
            
            const weightPool = [];
            availableTypes.forEach(type => {
                let baseWeight = 5;
                if (MINERALS[type].val > 500) baseWeight = 3;
                if (MINERALS[type].val > 1000) baseWeight = 1;
                const finalWeight = baseWeight * (this.buffs.spawnRates[type] || 1);
                
                if (finalWeight > 0) {
                    for(let k=0; k<finalWeight * 10; k++) weightPool.push(type);
                }
            });

            if (weightPool.length === 0) weightPool.push('ROCK');

            for(let i=0; i<count; i++) {
                const type = weightPool[Math.floor(Math.random() * weightPool.length)];
                let x = Math.random() * (CONFIG.width - 60) + 30;
                let y = CONFIG.groundY + 40 + Math.random() * (CONFIG.height - CONFIG.groundY - 80);
                this.entities.items.push(new Mineral(type, x, y));
            }

            // ç”Ÿæˆæ€ªç‰©
            if (isBoss) {
                this.entities.monsters.push(new Monster('BOSS', CONFIG.width/2, 200, this.level));
                document.getElementById('boss-hp-container').style.display = 'block';
            } else {
                document.getElementById('boss-hp-container').style.display = 'none';
                const monsterCount = 1 + Math.floor(this.level / 2);
                for(let i=0; i<monsterCount; i++) {
                    let type = (i % 2 === 0) ? 'SLIME' : 'BAT';
                    let x = 100 + Math.random() * (CONFIG.width - 200);
                    this.entities.monsters.push(new Monster(type, x, 100 + Math.random()*50, this.level));
                }
            }
        }

        updateSidebar() {
            const list = document.getElementById('mineral-list');
            list.innerHTML = '';
            
            const presentTypes = [...new Set(this.entities.items.map(i => i.type))];
            presentTypes.sort((a,b) => MINERALS[b].val - MINERALS[a].val);

            presentTypes.forEach(type => {
                const data = MINERALS[type];
                let effectText = '';
                const effectCode = this.buffs.mineralEffect[type];
                if (effectCode === 'POISON') effectText = 'é™„å¸¶: ä¸­æ¯’';
                else if (effectCode === 'BLEED') effectText = 'é™„å¸¶: æµè¡€';
                
                // Size Text
                const sizeMult = this.buffs.mineralSize[type];
                if (sizeMult > 1.1) effectText += (effectText?' ':'') + '[å·¨å‹]';
                else if (sizeMult < 0.9) effectText += (effectText?' ':'') + '[å¾®å‹]';

                let dmg = data.val;
                if (this.buffs.mineralDmg[type]) dmg = Math.floor(dmg * this.buffs.mineralDmg[type]);

                const div = document.createElement('div');
                div.className = 'info-card';
                div.innerHTML = `
                    <div class="info-icon">${data.icon}</div>
                    <div class="info-details">
                        <div class="info-name">${data.name}</div>
                        <div class="info-val">ATK: ${dmg}</div>
                        ${effectText ? `<div class="info-effect">${effectText}</div>` : ''}
                    </div>
                `;
                list.appendChild(div);
            });
        }

        endTurn() {
            if (this.turnAction) {
                if (this.turnAction.type === 'CRIT') {
                    const msg = `ğŸ”¥ çˆ†æ“Šï¼å–å¾— [${this.turnAction.mineral}]\nå…¨é«”è½Ÿç‚¸ ${this.turnAction.damage} é»å‚·å®³ï¼`;
                    this.showNotif(msg, "crit");
                } else if (this.turnAction.type === 'HIT') {
                    const targetText = this.turnAction.targetName || "æ€ªç‰©";
                    const msg = `å–å¾— [${this.turnAction.mineral}]ï¼\nå° ${targetText} é€ æˆ ${this.turnAction.damage} é»å‚·å®³`;
                    this.showNotif(msg, "hit");
                } else {
                    this.showNotif("ç©ºæ‰‹è€Œæ­¸...", "miss");
                }
                this.turnAction = null;
            } else {
                this.showNotif("å›åˆçµæŸ", "turn");
            }
            
            this.entities.monsters.forEach((m, idx) => {
                m.processTurn();
                if (m.dead) {
                    this.entities.monsters.splice(idx, 1);
                    this.checkLevelClear();
                }
            });

            if (this.currentHooks <= 0 && this.entities.monsters.length > 0) {
                 this.state = 'GAMEOVER';
                 document.getElementById('game-over-screen').classList.remove('hidden');
                 document.getElementById('end-reason').innerText = "æ›é‰¤è€—ç›¡ï¼Œæ€ªç‰©ä»å­˜æ´»";
                 document.getElementById('final-score').innerText = "æœ€çµ‚åˆ†æ•¸: " + Math.floor(this.score);
            }
        }

        checkLevelClear() {
            if (this.entities.monsters.length === 0) {
                this.state = 'REWARD';
                setTimeout(() => this.showRewardScreen(), 1000);
            }
        }

        showRewardScreen() {
            const screen = document.getElementById('reward-screen');
            const container = document.getElementById('card-container');
            const title = document.getElementById('reward-title');
            const subtitle = document.getElementById('reward-subtitle');
            
            screen.classList.remove('hidden');
            container.innerHTML = '';

            let type = 'MINERAL'; 
            if (this.level % 5 === 0) type = 'LEGENDARY'; 
            else if (this.level % 3 === 0) type = 'HOOK'; 

            if (type === 'LEGENDARY') {
                title.innerText = "å‚³èªªè­·ç¬¦é¸æ“‡"; title.style.color = "#f1c40f";
                subtitle.innerText = "Boss æ‰è½äº†ç¨€ä¸–çå¯¶...";
            } else if (type === 'HOOK') {
                title.innerText = "ç‰¹æ®Šæ›é‰¤æ”¹é€ "; title.style.color = "#e67e22";
                subtitle.innerText = "å·¥åŠæä¾›äº†æ–°çš„æŠ€è¡“...";
            } else {
                title.innerText = "ç¤¦ç‰©èƒ½åŠ›å¼·åŒ–"; title.style.color = "#3498db";
                subtitle.innerText = "é‡å°å·²ç™¼ç¾ç¤¦ç‰©é€²è¡Œå‡ç´š...";
            }

            for(let i=0; i<3; i++) {
                const cardData = CardGenerator.generate(type, this);
                const card = document.createElement('div');
                card.className = `card card-${type.toLowerCase()}`;
                if (type === 'LEGENDARY') card.classList.add('card-legendary');

                card.innerHTML = `
                    <div class="card-icon">${cardData.icon}</div>
                    <div class="card-title">${cardData.name}</div>
                    <div class="card-desc">${cardData.desc}</div>
                    <div class="card-type">${type}</div>
                `;
                card.onclick = () => {
                    cardData.apply(this);
                    this.level++;
                    this.prepareLevel();
                };
                container.appendChild(card);
            }
        }

        updateUI() {
            document.getElementById('score').innerText = Math.floor(this.score);
            document.getElementById('level').innerText = this.level;
            document.getElementById('hooks').innerText = `${this.currentHooks}/${this.maxHookCount}`;
            
            const boss = this.entities.monsters.find(m => m.type === 'BOSS');
            if (boss) {
                const pct = (boss.hp / boss.maxHp) * 100;
                document.getElementById('boss-hp-fill').style.width = `${Math.max(0, pct)}%`;
            }
        }

        loop(timestamp) {
            const dt = timestamp - this.lastTime;
            this.lastTime = timestamp;

            if (this.state === 'PLAYING') {
                this.update(dt);
                this.draw();
            }

            requestAnimationFrame(this.loop);
        }

        update(dt) {
            // Boss Effect
            if (this.bossEffectTimer > 0) this.bossEffectTimer--;

            let allHooksSwing = true;
            this.hooks.forEach(h => {
                const finished = h.update(); 
                if (finished) this.endTurn();
                if (h.state !== 'SWING') allHooksSwing = false;
            });

            this.entities.damageTexts.forEach((d, i) => {
                d.update();
                if (d.life <= 0) this.entities.damageTexts.splice(i, 1);
            });
        }

        draw() {
            const ctx = this.ctx;
            ctx.clearRect(0, 0, CONFIG.width, CONFIG.height);

            // Background
            ctx.fillStyle = '#111';
            ctx.fillRect(0, CONFIG.groundY, CONFIG.width, CONFIG.height);
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, CONFIG.width, CONFIG.groundY);
            ctx.strokeStyle = '#333';
            ctx.beginPath(); ctx.moveTo(0, CONFIG.groundY); ctx.lineTo(CONFIG.width, CONFIG.groundY); ctx.stroke();

            // Shake Effect if Boss Warning
            if (this.bossEffectTimer > 0) {
                const shake = Math.sin(Date.now() / 20) * 5;
                ctx.save();
                ctx.translate(shake, shake);
            }

            this.entities.items.forEach(i => i.draw(ctx));
            this.entities.monsters.forEach(m => m.draw(ctx));
            this.hooks.forEach(h => h.draw(ctx));
            this.entities.damageTexts.forEach(d => d.draw(ctx));

            if (this.bossEffectTimer > 0) {
                ctx.restore();
                // Boss Warning Overlay
                ctx.fillStyle = `rgba(255, 0, 0, ${0.3 + Math.sin(Date.now()/100)*0.1})`;
                ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);
                
                ctx.save();
                ctx.fillStyle = '#fff';
                ctx.font = '900 60px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'red';
                ctx.shadowBlur = 20;
                ctx.fillText("WARNING", CONFIG.width/2, CONFIG.height/2);
                ctx.font = 'bold 30px Arial';
                ctx.fillText("BOSS APPROACHING", CONFIG.width/2, CONFIG.height/2 + 50);
                ctx.restore();
            }
        }

        handleInput() {
            if (this.state !== 'PLAYING') return;

            const ready = this.hooks.every(h => h.state === 'SWING');
            
            if (ready && this.currentHooks > 0) {
                if (Math.random() > this.buffs.freeHookChance) {
                    this.currentHooks--;
                } else {
                    this.showNotif("å¹¸é‹! ä¸æ¶ˆè€—æ¬¡æ•¸", "legendary");
                }
                this.updateUI();

                if (this.buffs.doubleHook) {
                    const centerAngle = this.hooks[0].angle;
                    const h1 = new Hook(CONFIG.width/2, 70);
                    const h2 = new Hook(CONFIG.width/2, 70);
                    h1.angle = centerAngle - 0.15; h2.angle = centerAngle + 0.15;
                    h1.state = 'SHOOT'; h2.state = 'SHOOT';
                    this.hooks = [h1, h2];
                } else {
                    this.hooks.forEach(h => h.state = 'SHOOT');
                }
            } else if (this.currentHooks <= 0 && ready) {
                this.showNotif("æ²’æœ‰æ›é‰¤äº†!", "bleed");
            }
        }

        showNotif(text, type) {
            const area = document.getElementById('notification-area');
            const el = document.createElement('div');
            el.className = `notif notif-${type}`;
            el.innerText = text;
            area.appendChild(el);
            setTimeout(() => el.remove(), 2000);
        }
    }

    /* ================= éŠæˆ²ç‰©ä»¶é¡åˆ¥ ================= */

    class Hook {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.angle = Math.PI / 2;
            this.length = 20;
            this.state = 'SWING';
            this.dir = 1;
            this.grabbed = null;
        }

        update() {
            // é€Ÿåº¦é‚è¼¯ä¿®æ­£ï¼š
            // 1. é—œå¡é›£åº¦å€ç‡ï¼šæ¯å¤šä¸€é—œï¼Œæ“ºå‹•é€Ÿåº¦å¢åŠ  5% (level 10 = 1.5å€é€Ÿ, level 20 = 2å€é€Ÿ)
            const levelRate = 1 + (game.level * 0.05);
            // 2. ç©å®¶ Buff å€ç‡ï¼šä¾†è‡ªå¡ç‰‡å‡ç´š
            const buffRate = game.buffs.hookSpeed;
            
            let justFinished = false;

            if (this.state === 'SWING') {
                // æ“ºå‹•é€Ÿåº¦ï¼šéš¨é—œå¡è¶Šå¾Œé¢è¶Šå¿« (å¢åŠ ç„æº–é›£åº¦)
                this.angle += CONFIG.baseSwingSpeed * this.dir * buffRate * levelRate;
                if (this.angle < 0.1 || this.angle > Math.PI - 0.1) this.dir *= -1;
                this.length = 20;
            } else if (this.state === 'SHOOT') {
                // ç™¼å°„é€Ÿåº¦ï¼šä¸»è¦å— Buff å½±éŸ¿ï¼Œä½†çµ¦äºˆæ¥µå¾®å¹…çš„é—œå¡è£œå„Ÿ (æ¯é—œ+1%) ä¿æŒç¯€å¥
                this.length += CONFIG.baseShootSpeed * buffRate * (1 + game.level * 0.01);
                if (this.length > 800 || this.checkBoundaries()) {
                    this.state = 'RETRACT';
                } else {
                    this.checkCollision();
                }
            } else if (this.state === 'RETRACT') {
                let s = CONFIG.baseRetractSpeed * buffRate;
                if (this.grabbed) {
                    s = (CONFIG.baseRetractSpeed / this.grabbed.weight) * buffRate;
                }
                this.length -= s;
                if (this.length <= 20) {
                    this.reset();
                    justFinished = true;
                }
            }
            return justFinished;
        }

        checkCollision() {
            const tipX = this.x + Math.cos(this.angle) * this.length;
            const tipY = this.y + Math.sin(this.angle) * this.length;

            // ç¢°æ’åŠå¾‘å— hookSize å½±éŸ¿
            const hitRadius = 5 * game.buffs.hookSize;

            for (let item of game.entities.items) {
                if (Math.hypot(tipX - item.x, tipY - item.y) < item.radius + hitRadius) {
                    this.state = 'RETRACT';
                    this.grabbed = item;
                    // å¾å ´æ™¯ç§»é™¤
                    game.entities.items = game.entities.items.filter(i => i !== item);
                    return;
                }
            }
        }

        checkBoundaries() {
            const tx = this.x + Math.cos(this.angle) * this.length;
            const ty = this.y + Math.sin(this.angle) * this.length;
            return (tx < 0 || tx > CONFIG.width || ty > CONFIG.height);
        }

        reset() {
            this.length = 20;
            this.state = 'SWING';
            
            if (this.grabbed) {
                let damage = this.grabbed.data.val;
                const type = this.grabbed.type;
                if (game.buffs.mineralDmg[type]) damage *= game.buffs.mineralDmg[type];

                game.score += damage;
                
                const critRate = game.buffs.critChance || 0.15;
                const isCrit = Math.random() < critRate;

                if (isCrit) {
                    damage = Math.floor(damage * 1.5);
                    game.turnAction = {
                        type: 'CRIT',
                        mineral: this.grabbed.data.name,
                        damage: damage,
                        monsterCount: game.entities.monsters.length
                    };
                    game.entities.monsters.forEach(m => {
                        m.takeDamage(damage, this.grabbed.type, true);
                    });
                } else {
                    const targets = game.entities.monsters.filter(m => !m.dead);
                    if (targets.length > 0) {
                        const target = targets[Math.floor(Math.random() * targets.length)];
                        target.takeDamage(damage, this.grabbed.type, false);
                        game.turnAction = {
                            type: 'HIT',
                            mineral: this.grabbed.data.name,
                            damage: damage,
                            targetName: target.type === 'BOSS' ? 'BOSS' : 'æ€ªç‰©'
                        };
                    } else {
                        game.turnAction = {
                            type: 'HIT',
                            mineral: this.grabbed.data.name,
                            damage: 0,
                            targetName: 'è™›ç©º'
                        };
                    }
                }

                this.grabbed = null;
                game.updateUI();
            } else {
                game.turnAction = { type: 'MISS' };
            }

            if (game.hooks.length > 1 && game.hooks.every(h => h.state === 'SWING')) {
                const mainHook = game.hooks[0];
                mainHook.x = CONFIG.width/2; 
                game.hooks = [mainHook];
            }
        }

        draw(ctx) {
            const tx = this.x + Math.cos(this.angle) * this.length;
            const ty = this.y + Math.sin(this.angle) * this.length;

            ctx.lineWidth = 3; ctx.strokeStyle = '#aaa';
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(tx, ty); ctx.stroke();

            const size = 10 * game.buffs.hookSize;
            ctx.save(); ctx.translate(tx, ty); ctx.rotate(this.angle - Math.PI/2);
            ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI); ctx.stroke();
            if (this.grabbed) {
                ctx.rotate(-(this.angle - Math.PI/2)); ctx.translate(0, 15);
                this.grabbed.x = 0; this.grabbed.y = 0; this.grabbed.draw(ctx);
            }
            ctx.restore();
            ctx.fillStyle = '#f39c12'; ctx.beginPath(); ctx.arc(this.x, this.y, 15, 0, Math.PI*2); ctx.fill();
        }
    }

    class Mineral {
        constructor(type, x, y) {
            this.type = type;
            this.data = MINERALS[type];
            this.x = x; this.y = y;
            
            const sizeMult = game.buffs.mineralSize[type] || 1.0;
            this.radius = this.data.radius * sizeMult;
            this.weight = this.data.weight * (sizeMult > 1 ? 1.2 : (sizeMult < 1 ? 0.8 : 1.0));
        }
        draw(ctx) {
            ctx.save(); 
            ctx.translate(this.x, this.y);
            
            ctx.font = `${this.radius * 1.2}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 5;
            
            ctx.fillText(this.data.icon, 0, 0);
            
            ctx.restore();
        }
    }

    class Monster {
        constructor(type, x, y, level) {
            this.type = type;
            this.x = x; this.y = y;
            
            // è¡€é‡è¨ˆç®—
            let base = (type === 'BOSS') ? 2500 : 300; 
            let scale = (type === 'BOSS') ? 1.4 : 1.1; 
            
            this.maxHp = Math.floor(base * Math.pow(scale, Math.floor(level/5)));
            this.hp = this.maxHp;
            this.dead = false;

            this.status = { poison: 0, bleed: 0 };
        }

        processTurn() {
            if (this.dead) return;

            let totalDot = 0;
            if (this.status.poison > 0) {
                const poisonDmg = Math.ceil(this.maxHp * 0.02 * this.status.poison);
                this.hp -= poisonDmg;
                totalDot += poisonDmg;
                this.status.poison--;
            }
            if (this.status.bleed > 0) {
                const bleedDmg = 50 * this.status.bleed;
                this.hp -= bleedDmg;
                totalDot += bleedDmg;
                this.status.bleed--;
            }

            if (totalDot > 0) {
                game.entities.damageTexts.push(new DamageText("-" + totalDot + " (DOT)", this.x, this.y - 20, "#aaa"));
                if (this.hp <= 0) {
                    this.hp = 0;
                    this.dead = true;
                }
                if (this.type === 'BOSS') game.updateUI();
            }
        }

        takeDamage(dmg, sourceMineralType, isCrit) {
            const effect = game.buffs.mineralEffect[sourceMineralType];
            if (effect) {
                if (effect === 'POISON') {
                    this.status.poison += 1;
                    game.entities.damageTexts.push(new DamageText("ä¸­æ¯’å †ç–Š!", this.x, this.y - 40, "#2ecc71"));
                } else if (effect === 'BLEED') {
                    this.status.bleed += 1;
                    game.entities.damageTexts.push(new DamageText("æµè¡€å †ç–Š!", this.x, this.y - 40, "#c0392b"));
                }
            }

            this.hp -= dmg;
            
            const color = isCrit ? "#f1c40f" : "#fff";
            const fontSize = isCrit ? 36 : 20;
            game.entities.damageTexts.push(new DamageText(Math.floor(dmg), this.x, this.y, color, fontSize));

            if (this.hp <= 0) {
                this.hp = 0;
                this.dead = true;
            }
            
            if (this.type === 'BOSS') game.updateUI();
        }

        draw(ctx) {
            if (this.dead) return;
            const offset = Math.sin(Date.now()/300) * 5;
            ctx.save(); ctx.translate(this.x, this.y + offset);

            if (this.status.poison > 0) ctx.fillStyle = '#2ecc71';
            else if (this.status.bleed > 0) ctx.fillStyle = '#e74c3c';
            else ctx.fillStyle = (this.type === 'BOSS') ? '#8e44ad' : ((this.type === 'SLIME') ? '#27ae60' : '#7f8c8d');

            if (this.type === 'BOSS') {
                ctx.scale(2, 2);
                ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(15, 0); ctx.lineTo(10, 20); ctx.lineTo(-10, 20); ctx.lineTo(-15, 0); ctx.fill();
                ctx.fillStyle = 'yellow'; ctx.fillRect(-5, -5, 4, 4); ctx.fillRect(1, -5, 4, 4);
            } else {
                ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(-8, -5, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(8, -5, 3, 0, Math.PI*2); ctx.fill();
            }
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            if (this.type !== 'BOSS') {
                ctx.fillText(`HP: ${this.hp}/${this.maxHp}`, 0, -30);
                ctx.fillStyle = 'black'; ctx.fillRect(-20, 30, 40, 5);
                ctx.fillStyle = 'red'; ctx.fillRect(-20, 30, 40 * (this.hp/this.maxHp), 5);
            } else {
                ctx.font = 'bold 8px Arial';
                ctx.fillText(`HP: ${this.hp}/${this.maxHp}`, 0, -30);
            }
            
            if (this.status.poison > 0) {
                ctx.fillStyle = '#2ecc71'; ctx.font = '10px Arial'; ctx.fillText('â˜ ï¸'+this.status.poison, 20, -10);
            }
            if (this.status.bleed > 0) {
                ctx.fillStyle = '#e74c3c'; ctx.font = '10px Arial'; ctx.fillText('ğŸ©¸'+this.status.bleed, 20, 5);
            }

            ctx.restore();
        }
    }

    class DamageText {
        constructor(text, x, y, color, size = 20) {
            this.text = text; this.x = x; this.y = y; this.color = color;
            this.size = size;
            this.life = 1.0;
        }
        update() { this.y -= 0.8; this.life -= 0.02; }
        draw(ctx) {
            ctx.save(); ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px Arial`;
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }
    }

    const CardGenerator = {
        generate(type, gameInstance) {
            if (type === 'LEGENDARY') {
                const list = [
                    { name: 'é›™é‡æ›é‰¤', desc: 'ä¸€æ¬¡å°„å‡ºå…©å€‹æ›é‰¤ï¼Œæ•ˆç‡åŠ å€ï¼Œåƒ…æ¶ˆè€— 1 æ¬¡æ¬¡æ•¸', icon: 'ğŸ”±', apply: (g) => { g.buffs.doubleHook = true; } },
                    { name: 'å¹¸é‹å›æ”¶', desc: 'å°„å‡ºæ›é‰¤æ™‚æœ‰ 30% æ©Ÿç‡ä¸æ¶ˆè€—æ¬¡æ•¸', icon: 'ğŸ€', apply: (g) => { g.buffs.freeHookChance += 0.3; } },
                    { name: 'è±é¥’è™Ÿè§’', desc: 'é—œå¡ä¸­çš„ç¤¦ç‰©ç¸½æ•¸å¢åŠ  5 å€‹', icon: 'ğŸŒ½', apply: (g) => { g.buffs.extraMineralCount += 5; } },
                    { name: 'æœƒå¿ƒä¸€æ“Š', desc: 'çˆ†æ“Šæ©Ÿç‡ +20%ï¼Œçˆ†æ“Šå‚·å®³å†æå‡', icon: 'ğŸ¯', apply: (g) => { g.buffs.critChance += 0.2; }}
                ];
                return list[Math.floor(Math.random()*list.length)];
            } else if (type === 'HOOK') {
                const list = [
                    { name: 'æ“´å……å½ˆåŒ£', desc: 'æœ€å¤§æ›é‰¤æ¬¡æ•¸ +5', icon: 'ğŸ’', apply: (g) => { g.maxHookCount += 5; } },
                    { name: 'å·¨å‹é‰¤çˆª', desc: 'æ›é‰¤åˆ¤å®šç¯„åœåŠ å¤§ 50%', icon: 'ğŸª', apply: (g) => { g.buffs.hookSize += 0.5; } },
                    { name: 'æ¶²å£“é¦¬é”', desc: 'æ›é‰¤ç™¼å°„èˆ‡æ”¶å›é€Ÿåº¦ +20%', icon: 'âš™ï¸', apply: (g) => { g.buffs.hookSpeed *= 1.2; } }
                ];
                return list[Math.floor(Math.random()*list.length)];
            } else {
                let validKeys = Array.from(gameInstance.discoveredMinerals).filter(k => k !== 'BAG');
                if (validKeys.length === 0 || (validKeys.length === 1 && validKeys[0] === 'ROCK')) {
                    validKeys = ['ROCK', 'COPPER']; 
                }

                const target = validKeys[Math.floor(Math.random()*validKeys.length)];
                const mName = MINERALS[target].name;
                
                const effects = [
                    { suffix: 'æ·¬æ¯’', desc: 'å‘½ä¸­è³¦äºˆä¸­æ¯’ (ç™¾åˆ†æ¯”å‚·å®³)', code: 'POISON', icon: 'ğŸ§ª' },
                    { suffix: 'é‹¸é½’', desc: 'å‘½ä¸­è³¦äºˆæµè¡€ (å›ºå®šå‚·å®³)', code: 'BLEED', icon: 'ğŸ©¸' },
                    { suffix: 'é‡æ“Š', desc: 'å‚·å®³ +100%', code: 'DMG', icon: 'ğŸ’¥' },
                    { suffix: 'ç¤¦è„ˆ', desc: 'å‡ºç¾é »ç‡å¤§å¹…å¢åŠ ', code: 'SPAWN', icon: 'ğŸ“ˆ' },
                    { suffix: 'å·¨å‹åŒ–', desc: 'é«”ç©è®Šå¤§ 50%ï¼Œå®¹æ˜“æŠ“å–ä½†è®Šé‡', code: 'SIZE_UP', icon: 'â«' },
                    { suffix: 'å¾®ç¸®åŒ–', desc: 'é«”ç©ç¸®å° 40%ï¼Œè®Šè¼•', code: 'SIZE_DOWN', icon: 'â¬' },
                    { suffix: 'æ¯ç«­', desc: 'å‡ºç¾é »ç‡å¤§å¹…é™ä½', code: 'SPAWN_DOWN', icon: 'ğŸ“‰' }
                ];
                const eff = effects[Math.floor(Math.random()*effects.length)];
                
                return {
                    name: `${mName}${eff.suffix}`, desc: `${mName} ${eff.desc}`, icon: eff.icon,
                    apply: (g) => {
                        if (eff.code === 'DMG') {
                            g.buffs.mineralDmg[target] = (g.buffs.mineralDmg[target] || 1) + 1.0;
                        } else if (eff.code === 'SPAWN') {
                            g.buffs.spawnRates[target] = (g.buffs.spawnRates[target] || 1) + 2; 
                        } else if (eff.code === 'SPAWN_DOWN') {
                            g.buffs.spawnRates[target] = (g.buffs.spawnRates[target] || 1) * 0.2;
                        } else if (eff.code === 'SIZE_UP') {
                            g.buffs.mineralSize[target] = (g.buffs.mineralSize[target] || 1) * 1.5;
                        } else if (eff.code === 'SIZE_DOWN') {
                            g.buffs.mineralSize[target] = (g.buffs.mineralSize[target] || 1) * 0.6;
                        } else {
                            g.buffs.mineralEffect[target] = eff.code;
                        }
                    }
                };
            }
        }
    };

    /* ================= å•Ÿå‹• ================= */
    const game = new Game();

    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.code === 'ArrowDown') game.handleInput();
    });
    
    document.getElementById('gameCanvas').addEventListener('mousedown', () => game.handleInput());
    document.getElementById('gameCanvas').addEventListener('touchstart', (e) => { e.preventDefault(); game.handleInput(); });

</script>
</body>
</html>