<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <!-- é—œéµï¼šviewport-fit=cover è®“ç•«é¢èƒ½å»¶ä¼¸åˆ°ç€æµ·å€ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>é»ƒé‡‘ç¤¦å·¥ Rogue</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000; /* é»‘è‰²èƒŒæ™¯å¡«å……å¤šé¤˜ç©ºé–“ */
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Microsoft JhengHei', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* ç¸®æ”¾å®¹å™¨ï¼šç§»é™¤é‚Šæ¡†é™°å½±ï¼Œè®“å®ƒèå…¥èƒŒæ™¯ */
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            background: #111;
            /* é‚Šæ¡†ç¨å¾®èª¿ç´°ï¼Œç”šè‡³å¯ä»¥è€ƒæ…®ç§»é™¤ï¼Œé€™è£¡ä¿ç•™ä¸€é»è³ªæ„Ÿ */
            border: 2px solid #3e2723; 
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            transform-origin: center center;
            /* é è¨­éš±è—ï¼Œç­‰ JS è¨ˆç®—å¥½ç¸®æ”¾å†é¡¯ç¤ºï¼Œé¿å…é–ƒçˆ */
            opacity: 0; 
            transition: opacity 0.2s;
        }

        /* å…¨è¢å¹•æŒ‰éˆ• - æ”¹ç‚ºåŠé€æ˜æ‡¸æµ®åœ–ç¤º */
        #fullscreen-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 999;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            -webkit-user-select: none;
        }

        /* å·¦å´è³‡è¨Šæ¬„ */
        #sidebar {
            width: 180px;
            background: #1a1a1a;
            border-right: 2px solid #3e2723;
            padding: 10px;
            overflow-y: auto;
            color: #ddd;
            font-size: 14px;
            z-index: 10;
            flex-shrink: 0;
            transition: transform 0.3s ease;
        }

        #sidebar h3 {
            color: #f1c40f;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
            margin-top: 0;
            text-align: center;
        }

        /* æ‰‹æ©Ÿç‰ˆå´é‚Šæ¬„åˆ‡æ›æŒ‰éˆ• - å„ªåŒ–ä½ç½® */
        #sidebar-toggle {
            display: none;
            position: absolute;
            top: 10px;
            left: 10px;
            width: 44px;
            height: 44px;
            background: rgba(62, 39, 35, 0.8);
            border: 2px solid #f1c40f;
            border-radius: 8px;
            color: white;
            font-size: 24px;
            cursor: pointer;
            z-index: 100;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        }

        /* éŠæˆ²ä¸»ç•«é¢å€å¡Š */
        #main-area {
            position: relative; 
            flex: 1; 
            display: flex; 
            flex-direction: column;
            /* width æœƒç”± flex è‡ªå‹•å¡«æ»¿å‰©é¤˜ç©ºé–“ */
            height: 100%;
        }

        canvas {
            display: block;
            background: #111;
            width: 100%;
            height: 100%;
        }

        /* UI å±¤ */
        #ui-layer {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            font-size: 20px;
            z-index: 5;
        }

        .ui-box {
            background: rgba(0, 0, 0, 0.5); /* åŠé€æ˜ */
            padding: 5px 12px;
            border-radius: 15px;
            border: 1px solid #5d4037;
            display: flex;
            align-items: center;
            font-weight: bold;
        }
        
        .highlight { color: #f1c40f; margin-left: 5px; }
        .hook-count { color: #3498db; margin-left: 5px; }

        #boss-hp-container {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            width: 70%; height: 20px; background: #111;
            border: 2px solid #555; border-radius: 10px; display: none; overflow: hidden;
        }
        #boss-hp-fill { width: 100%; height: 100%; background: #c0392b; transition: width 0.2s; }
        #boss-name { position: absolute; top: -25px; left: 0; width: 100%; text-align: center; color: #e74c3c; font-weight: bold; text-shadow: 1px 1px 0 #000; font-size: 16px; }

        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 10, 0.95);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 20; text-align: center;
        }
        .hidden { display: none !important; }
        
        .btn {
            padding: 12px 30px; font-size: 20px;
            background: #c0392b; color: white;
            border: none; border-radius: 8px; cursor: pointer; margin-top: 20px;
            box-shadow: 0 4px 0 #7b241c;
        }
        .btn:active { transform: translateY(4px); box-shadow: none; }

        .info-card {
            background: #222; border: 1px solid #444; border-radius: 5px;
            padding: 8px; margin-bottom: 8px; display: flex; align-items: center; gap: 10px;
        }
        .info-icon { font-size: 28px; width: 40px; text-align: center; }
        .info-details { flex: 1; }
        .info-name { font-weight: bold; font-size: 13px; }
        .info-val { color: #2ecc71; font-size: 12px; }
        .info-effect { color: #e67e22; font-size: 11px; }

        /* é€šçŸ¥ */
        #notification-area {
            position: absolute; top: 70px; right: 10px; width: 180px;
            display: flex; flex-direction: column; gap: 5px; pointer-events: none; z-index: 6;
        }
        .notif {
            background: rgba(0,0,0,0.8); color: #fff; padding: 8px;
            border-radius: 4px; font-size: 13px; border-left: 4px solid #fff;
            animation: fadeOut 2.5s forwards; text-align: left;
        }
        @keyframes fadeOut {
            0% { opacity: 0; transform: translateX(20px); }
            10% { opacity: 1; transform: translateX(0); }
            85% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-10px); }
        }
        .notif-poison { border-left-color: #2ecc71; }
        .notif-bleed { border-left-color: #e74c3c; }
        .notif-hit { border-left-color: #f1c40f; }
        .notif-crit { border-left-color: #ff0000; color: #ffcccc; font-weight: bold; }

        /* å¡ç‰‡ */
        .card-container { display: flex; gap: 15px; margin-top: 20px; flex-wrap: wrap; justify-content: center; }
        .card {
            width: 150px; height: 240px; background: #222;
            border: 2px solid #555; border-radius: 10px; padding: 10px;
            display: flex; flex-direction: column; align-items: center;
            cursor: pointer; position: relative;
        }
        .card-icon { font-size: 36px; margin-bottom: 5px; }
        .card-title { font-size: 15px; font-weight: bold; margin-bottom: 5px; color: white; }
        .card-desc { font-size: 12px; color: #ccc; line-height: 1.3; }
        .card-mineral { border-color: #3498db; background: linear-gradient(180deg, #1a2a3a, #000); }
        .card-hook { border-color: #e67e22; background: linear-gradient(180deg, #3a2a1a, #000); }
        .card-legendary { border-color: #f1c40f; background: linear-gradient(180deg, #3a3a1a, #2c0000); }

        /* å½ˆçª— */
        #discovery-popup {
            background: #1a1a1a; border: 2px solid #f1c40f; padding: 20px;
            border-radius: 10px; max-width: 300px; width: 85%; text-align: center;
        }
        .disco-icon { font-size: 60px; margin: 10px 0; display: block; }
        .disco-stats { color: #2ecc71; font-size: 20px; font-weight: bold; margin: 10px 0; }

        /* æ‰‹æ©Ÿé©é… CSS */
        @media (max-width: 850px) {
            #sidebar {
                position: absolute; left: 0; top: 0; bottom: 0;
                transform: translateX(-100%);
                box-shadow: 5px 0 15px rgba(0,0,0,0.9);
                background: rgba(26, 26, 26, 0.95); /* å¾®é€æ˜èƒŒæ™¯ */
                backdrop-filter: blur(5px);
            }
            #sidebar.active { transform: translateX(0); }
            #sidebar-toggle { display: flex; }
            
            #main-area { width: 100%; }
            #ui-layer { left: 60px; font-size: 16px; } 
            .ui-box { padding: 4px 10px; }
        }

    </style>
</head>
<body>

<div id="fullscreen-btn" onclick="toggleFullScreen()">â›¶</div>

<div id="game-container">
    <div id="sidebar-toggle" onclick="toggleSidebar()">ğŸ“–</div>

    <div id="sidebar">
        <h3>æœ¬é—œç¤¦ç‰©</h3>
        <div id="mineral-list"></div>
    </div>

    <div id="main-area">
        <canvas id="gameCanvas" width="620" height="600"></canvas>
        
        <div id="ui-layer">
            <div class="ui-box">åˆ†æ•¸ <span id="score" class="highlight">0</span></div>
            <div class="ui-box">é—œå¡ <span id="level" class="highlight">1</span></div>
            <div class="ui-box" style="border-color: #3498db;">æ›é‰¤ <span id="hooks" class="hook-count">10</span></div>
        </div>

        <div id="boss-hp-container">
            <div id="boss-name">BOSS</div>
            <div id="boss-hp-fill"></div>
        </div>

        <div id="notification-area"></div>

        <div id="discovery-screen" class="overlay-screen hidden">
            <div id="discovery-popup">
                <h2 style="color: #3498db;">æ–°ç¤¦ç‰©è§£é–ï¼</h2>
                <div id="disco-icon" class="disco-icon"></div>
                <h3 id="disco-name" style="font-size: 28px; color:white;"></h3>
                <div id="disco-stats" class="disco-stats"></div>
                <p id="disco-desc" style="color: #ccc;"></p>
                <button class="btn" onclick="game.closeDiscovery()">ç¢ºèª</button>
            </div>
        </div>

        <!-- ç•«é¢: é–‹å§‹ -->
        <div id="start-screen" class="overlay-screen">
            <h1 style="color: #f1c40f; font-size: 42px; margin-bottom: 10px;">é»ƒé‡‘ç¤¦å·¥ Rogue</h1>
            <h2 style="color: #ccc; font-size: 20px;">å›åˆåˆ¶æˆ°ç•¥ç‰ˆ</h2>
            <div style="text-align: center; max-width: 500px; line-height: 1.6; color: #aaa; margin: 20px;">
                <p>æ¯æ¬¡å‡ºé‰¤è¦–ç‚º<span style="color:#e74c3c">ä¸€å›åˆ</span>ã€‚</p>
                <p>æ™®é€šæ”»æ“Šç‚ºå–®é«”ï¼Œ<span style="color:#f1c40f">çˆ†æ“Š</span>æ‰æœƒè§¸ç™¼<span style="color:#f1c40f">å…¨é«”å‚·å®³</span>ã€‚</p>
                <p>ç‹€æ…‹æ•ˆæœ(ä¸­æ¯’/æµè¡€)æœƒç–ŠåŠ å±¤æ•¸ï¼Œ<br>æ¯å›åˆé€ æˆå‚·å®³å¾Œå±¤æ•¸éæ¸›ã€‚</p>
                <p>æ”¶é›†å¡ç‰Œï¼šå¯å°‡ç¤¦ç‰©<span style="color:#3498db">è®Šå¤§/è®Šå°</span>æˆ–<span style="color:#3498db">æ§åˆ¶å‡ºç¾ç‡</span>ã€‚</p>
            </div>
            <button class="btn" onclick="game.start()">é–‹å§‹å†’éšª</button>
        </div>

        <div id="reward-screen" class="overlay-screen hidden">
            <h2 id="reward-title" style="color: #f1c40f;">æˆ°åˆ©å“</h2>
            <p style="color: #aaa;">åªèƒ½é¸æ“‡ä¸€å¼µ</p>
            <div id="card-container" class="card-container"></div>
        </div>

        <div id="game-over-screen" class="overlay-screen hidden">
            <h1 style="color: #e74c3c;">çµæŸ</h1>
            <p id="end-reason" style="margin: 10px 0; font-size: 20px; color: #ccc;"></p>
            <p id="final-score" style="font-size: 24px; color: #f1c40f; margin-bottom: 30px;"></p>
            <button class="btn" onclick="game.start()">é‡ä¾†</button>
        </div>
    </div>
</div>

<script>
    // === å¼·åˆ¶ç¸®æ”¾é‚è¼¯ (Max Size Fix) ===
    function resizeGame() {
        const container = document.getElementById('game-container');
        const baseWidth = 800;
        const baseHeight = 600;
        
        const winWidth = window.innerWidth;
        const winHeight = window.innerHeight;
        
        // è¨ˆç®—èƒ½å¡«æ»¿è¢å¹•çš„æœ€å¤§ç¸®æ”¾æ¯”ä¾‹ (ä¸ç•™ 5% é‚Šè·)
        const scale = Math.min(winWidth / baseWidth, winHeight / baseHeight);

        container.style.transform = `scale(${scale})`;
        container.style.opacity = 1; // è¨ˆç®—å®Œå†é¡¯ç¤º
    }

    window.addEventListener('resize', resizeGame);
    window.addEventListener('load', resizeGame);
    document.addEventListener('dblclick', (e) => e.preventDefault(), { passive: false });

    function toggleSidebar() { document.getElementById('sidebar').classList.toggle('active'); }
    function toggleFullScreen() {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e=>{});
        else if (document.exitFullscreen) document.exitFullscreen();
    }

    // === éŠæˆ²é‚è¼¯ ===
    const MINERALS = {
        ROCK:    { name: 'å²©çŸ³', val: 100, weight: 5.0, radius: 35, icon: 'ğŸª¨', unlockLv: 1, desc: 'æ™®é€šçš„çŸ³é ­ã€‚' },
        COPPER:  { name: 'éŠ…ç¤¦', val: 300, weight: 2.0, radius: 20, icon: 'ğŸŸ ', unlockLv: 1, desc: 'è¼•ä¾¿çš„é‡‘å±¬ã€‚' },
        SILVER:  { name: 'ç™½éŠ€', val: 500, weight: 2.5, radius: 22, icon: 'âšª', unlockLv: 2, desc: 'æœ‰åƒ¹å€¼çš„é‡‘å±¬ã€‚' },
        IRON:    { name: 'éµç¤¦', val: 200, weight: 3.5, radius: 24, icon: 'ğŸ›¡ï¸', unlockLv: 3, desc: 'å …ç¡¬çš„éµç¤¦ã€‚' },
        GOLD:    { name: 'é»ƒé‡‘', val: 1000, weight: 4.0, radius: 25, icon: 'ğŸŸ¡', unlockLv: 4, desc: 'é–ƒè€€çš„è²¡å¯Œã€‚' },
        RUBY:    { name: 'ç´…å¯¶çŸ³', val: 1500, weight: 1.2, radius: 12, icon: 'ğŸ”º', unlockLv: 6, desc: 'ç«ç„°ä¹‹åŠ›ã€‚' },
        EMERALD: { name: 'ç¥–æ¯ç¶ ', val: 1200, weight: 1.3, radius: 14, icon: 'ğŸŸ©', unlockLv: 8, desc: 'è‡ªç„¶æ¯’ç´ ã€‚' },
        DIAMOND: { name: 'é‘½çŸ³', val: 2500, weight: 0.8, radius: 10, icon: 'ğŸ’', unlockLv: 10, desc: 'æœ€å …ç¡¬ç‰©è³ªã€‚' }
    };

    const CONFIG = { width: 620, height: 600, groundY: 120, baseSwingSpeed: 0.02, baseShootSpeed: 8, baseRetractSpeed: 12 };

    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.state = 'MENU';
            this.score = 0; this.level = 1;
            this.discoveredMinerals = new Set(); this.newDiscoveryQueue = []; 
            this.maxHookCount = 10; this.currentHooks = 10;
            this.buffs = { mineralDmg: {}, mineralEffect: {}, spawnRates: {}, mineralSize: {}, extraMineralCount: 0, hookSize: 1.0, hookSpeed: 1.0, doubleHook: false, freeHookChance: 0.0, critChance: 0.15 };
            this.entities = { items: [], monsters: [], damageTexts: [] };
            this.hooks = []; this.lastTime = 0; this.turnAction = null; this.bossEffectTimer = 0;
        }

        start() {
            this.score = 0; this.level = 1; this.currentHooks = 10; this.maxHookCount = 10;
            this.discoveredMinerals.clear();
            this.buffs = { mineralDmg: {}, mineralEffect: {}, spawnRates: {}, mineralSize: {}, extraMineralCount: 0, hookSize: 1.0, hookSpeed: 1.0, doubleHook: false, freeHookChance: 0.0, critChance: 0.15 };
            Object.keys(MINERALS).forEach(k => { this.buffs.spawnRates[k] = 1; this.buffs.mineralSize[k] = 1; });
            this.discoveredMinerals.add('ROCK'); this.discoveredMinerals.add('COPPER');
            this.prepareLevel();
            this.loop = this.loop.bind(this);
            requestAnimationFrame(this.loop);
        }

        prepareLevel() {
            document.querySelectorAll('.overlay-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('sidebar').classList.remove('active');
            this.currentHooks = this.maxHookCount; this.updateUI(); this.bossEffectTimer = 0;
            this.hooks = [new Hook(CONFIG.width/2, 70)]; 
            this.generateLevelData(); this.updateSidebar();
            
            const currentLevelMinerals = this.entities.items.map(i => i.type);
            const uniqueTypes = [...new Set(currentLevelMinerals)];
            this.newDiscoveryQueue = uniqueTypes.filter(t => !this.discoveredMinerals.has(t));
            if (this.newDiscoveryQueue.length > 0) this.showNextDiscovery(); else this.state = 'PLAYING';
        }

        showNextDiscovery() {
            if (this.newDiscoveryQueue.length === 0) { document.getElementById('discovery-screen').classList.add('hidden'); this.state = 'PLAYING'; return; }
            const type = this.newDiscoveryQueue.shift(); this.discoveredMinerals.add(type);
            const data = MINERALS[type];
            document.getElementById('discovery-screen').classList.remove('hidden');
            document.getElementById('disco-icon').innerText = data.icon;
            document.getElementById('disco-name').innerText = data.name;
            document.getElementById('disco-stats').innerText = `ATK: ${data.val}`;
            document.getElementById('disco-desc').innerText = data.desc;
        }
        closeDiscovery() { this.showNextDiscovery(); }

        generateLevelData() {
            this.entities.items = []; this.entities.monsters = []; this.entities.damageTexts = [];
            const isBoss = (this.level % 5 === 0);
            if (isBoss) this.bossEffectTimer = 180; 
            const availableTypes = Object.keys(MINERALS).filter(k => MINERALS[k].unlockLv <= this.level);
            const count = 12 + Math.min(this.level, 8) + this.buffs.extraMineralCount;
            const weightPool = [];
            availableTypes.forEach(type => {
                let baseWeight = 5;
                if (MINERALS[type].val > 500) baseWeight = 3;
                if (MINERALS[type].val > 1000) baseWeight = 1;
                const finalWeight = baseWeight * (this.buffs.spawnRates[type] || 1);
                if (finalWeight > 0) for(let k=0; k<finalWeight * 10; k++) weightPool.push(type);
            });
            if (weightPool.length === 0) weightPool.push('ROCK');
            for(let i=0; i<count; i++) {
                const type = weightPool[Math.floor(Math.random() * weightPool.length)];
                let x = Math.random() * (CONFIG.width - 60) + 30;
                let y = CONFIG.groundY + 40 + Math.random() * (CONFIG.height - CONFIG.groundY - 80);
                this.entities.items.push(new Mineral(type, x, y));
            }
            if (isBoss) {
                this.entities.monsters.push(new Monster('BOSS', CONFIG.width/2, 200, this.level));
                document.getElementById('boss-hp-container').style.display = 'block';
            } else {
                document.getElementById('boss-hp-container').style.display = 'none';
                const monsterCount = 1 + Math.floor(this.level / 2);
                for(let i=0; i<monsterCount; i++) {
                    let type = (i % 2 === 0) ? 'SLIME' : 'BAT';
                    let x = 100 + Math.random() * (CONFIG.width - 200);
                    this.entities.monsters.push(new Monster(type, x, 100 + Math.random()*50, this.level));
                }
            }
        }

        updateSidebar() {
            const list = document.getElementById('mineral-list'); list.innerHTML = '';
            const presentTypes = [...new Set(this.entities.items.map(i => i.type))];
            presentTypes.sort((a,b) => MINERALS[b].val - MINERALS[a].val);
            presentTypes.forEach(type => {
                const data = MINERALS[type];
                let effectText = '';
                const effectCode = this.buffs.mineralEffect[type];
                if (effectCode === 'POISON') effectText = 'ä¸­æ¯’';
                else if (effectCode === 'BLEED') effectText = 'æµè¡€';
                const sizeMult = this.buffs.mineralSize[type];
                if (sizeMult > 1.1) effectText += ' å·¨å‹'; else if (sizeMult < 0.9) effectText += ' å¾®å‹';
                let dmg = Math.floor(data.val * (this.buffs.mineralDmg[type] || 1));
                const div = document.createElement('div'); div.className = 'info-card';
                div.innerHTML = `<div class="info-icon">${data.icon}</div><div class="info-details"><div class="info-name">${data.name}</div><div class="info-val">ATK: ${dmg}</div><div class="info-effect">${effectText}</div></div>`;
                list.appendChild(div);
            });
        }

        endTurn() {
            if (this.turnAction) {
                let msg = '', type = '';
                if (this.turnAction.type === 'CRIT') { msg = `ğŸ”¥ çˆ†æ“Š! [${this.turnAction.mineral}]\nå…¨é«” ${this.turnAction.damage} å‚·`; type = "crit"; }
                else if (this.turnAction.type === 'HIT') { msg = `[${this.turnAction.mineral}]\n${this.turnAction.damage} å‚·`; type = "hit"; }
                else { msg = "ç©ºæ‰‹è€Œæ­¸"; type = "miss"; }
                this.showNotif(msg, type);
                this.turnAction = null;
            } else { this.showNotif("å›åˆçµæŸ", "turn"); }
            
            this.entities.monsters.forEach((m, idx) => {
                m.processTurn();
                if (m.dead) { this.entities.monsters.splice(idx, 1); this.checkLevelClear(); }
            });

            if (this.currentHooks <= 0 && this.entities.monsters.length > 0) {
                 this.state = 'GAMEOVER';
                 document.getElementById('game-over-screen').classList.remove('hidden');
                 document.getElementById('end-reason').innerText = "æ›é‰¤è€—ç›¡";
                 document.getElementById('final-score').innerText = "åˆ†: " + Math.floor(this.score);
            }
        }

        checkLevelClear() {
            if (this.entities.monsters.length === 0) {
                this.state = 'REWARD';
                setTimeout(() => this.showRewardScreen(), 1000);
            }
        }

        showRewardScreen() {
            const screen = document.getElementById('reward-screen');
            const container = document.getElementById('card-container');
            const title = document.getElementById('reward-title');
            screen.classList.remove('hidden'); container.innerHTML = '';
            let type = (this.level % 5 === 0) ? 'LEGENDARY' : ((this.level % 3 === 0) ? 'HOOK' : 'MINERAL');
            
            if(type==='LEGENDARY'){ title.innerText="å‚³èªªè­·ç¬¦"; title.style.color="#f1c40f"; }
            else if(type==='HOOK'){ title.innerText="æ›é‰¤æ”¹é€ "; title.style.color="#e67e22"; }
            else { title.innerText="èƒ½åŠ›å¼·åŒ–"; title.style.color="#3498db"; }

            for(let i=0; i<3; i++) {
                const cardData = CardGenerator.generate(type, this);
                const card = document.createElement('div');
                card.className = `card card-${type.toLowerCase()}`;
                if (type === 'LEGENDARY') card.classList.add('card-legendary');
                card.innerHTML = `<div class="card-icon">${cardData.icon}</div><div class="card-title">${cardData.name}</div><div class="card-desc">${cardData.desc}</div>`;
                card.onclick = () => {
                    cardData.apply(this); this.level++; this.prepareLevel();
                };
                container.appendChild(card);
            }
        }

        updateUI() {
            document.getElementById('score').innerText = Math.floor(this.score);
            document.getElementById('level').innerText = this.level;
            document.getElementById('hooks').innerText = `${this.currentHooks}/${this.maxHookCount}`;
            const boss = this.entities.monsters.find(m => m.type === 'BOSS');
            if (boss) document.getElementById('boss-hp-fill').style.width = `${Math.max(0, (boss.hp/boss.maxHp)*100)}%`;
        }

        loop(timestamp) {
            const dt = timestamp - this.lastTime; this.lastTime = timestamp;
            if (this.state === 'PLAYING') { this.update(dt); this.draw(); }
            requestAnimationFrame(this.loop);
        }

        update(dt) {
            if (this.bossEffectTimer > 0) this.bossEffectTimer--;
            let allHooksSwing = true;
            this.hooks.forEach(h => {
                const finished = h.update();
                if (finished) this.endTurn();
                if (h.state !== 'SWING') allHooksSwing = false;
            });
            this.entities.damageTexts.forEach((d, i) => {
                d.update(); if (d.life <= 0) this.entities.damageTexts.splice(i, 1);
            });
        }

        draw() {
            const ctx = this.ctx; ctx.clearRect(0, 0, CONFIG.width, CONFIG.height);
            ctx.fillStyle = '#111'; ctx.fillRect(0, CONFIG.groundY, CONFIG.width, CONFIG.height);
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, CONFIG.width, CONFIG.groundY);
            ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.moveTo(0, CONFIG.groundY); ctx.lineTo(CONFIG.width, CONFIG.groundY); ctx.stroke();

            if (this.bossEffectTimer > 0) {
                const shake = Math.sin(Date.now() / 20) * 5; ctx.save(); ctx.translate(shake, shake);
            }
            this.entities.items.forEach(i => i.draw(ctx));
            this.entities.monsters.forEach(m => m.draw(ctx));
            this.hooks.forEach(h => h.draw(ctx));
            this.entities.damageTexts.forEach(d => d.draw(ctx));
            if (this.bossEffectTimer > 0) {
                ctx.restore(); ctx.fillStyle = `rgba(255, 0, 0, ${0.3 + Math.sin(Date.now()/100)*0.1})`;
                ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);
                ctx.fillStyle = '#fff'; ctx.font = '900 50px Arial'; ctx.textAlign = 'center';
                ctx.fillText("WARNING", CONFIG.width/2, CONFIG.height/2);
            }
        }

        handleInput() {
            if (this.state !== 'PLAYING') return;
            const ready = this.hooks.every(h => h.state === 'SWING');
            if (ready && this.currentHooks > 0) {
                if (Math.random() > this.buffs.freeHookChance) this.showNotif("å¹¸é‹! å…è€—æ¬¡æ•¸", "crit");
                else this.currentHooks--;
                this.updateUI();
                if (this.buffs.doubleHook) {
                    const a = this.hooks[0].angle;
                    const h1 = new Hook(CONFIG.width/2, 70); h1.angle = a - 0.15;
                    const h2 = new Hook(CONFIG.width/2, 70); h2.angle = a + 0.15;
                    h1.state = 'SHOOT'; h2.state = 'SHOOT';
                    this.hooks = [h1, h2];
                } else { this.hooks.forEach(h => h.state = 'SHOOT'); }
            } else if (this.currentHooks <= 0 && ready) {
                this.showNotif("æ²’æ›é‰¤äº†!", "bleed");
            }
        }

        showNotif(text, type) {
            const area = document.getElementById('notification-area');
            const el = document.createElement('div'); el.className = `notif notif-${type}`; el.innerText = text;
            area.appendChild(el); setTimeout(() => el.remove(), 2500);
        }
    }

    class Hook {
        constructor(x, y) {
            this.x = x; this.y = y; this.angle = Math.PI / 2; this.length = 20;
            this.state = 'SWING'; this.dir = 1; this.grabbed = null;
        }
        update() {
            const lr = 1 + (game.level * 0.05); const br = game.buffs.hookSpeed;
            let finished = false;
            if (this.state === 'SWING') {
                this.angle += CONFIG.baseSwingSpeed * this.dir * br * lr;
                if (this.angle < 0.1 || this.angle > Math.PI - 0.1) this.dir *= -1;
                this.length = 20;
            } else if (this.state === 'SHOOT') {
                this.length += CONFIG.baseShootSpeed * br * (1+game.level*0.01);
                if (this.length > 800 || this.checkBoundaries()) this.state = 'RETRACT';
                else this.checkCollision();
            } else if (this.state === 'RETRACT') {
                let s = CONFIG.baseRetractSpeed * br;
                if (this.grabbed) s = (CONFIG.baseRetractSpeed / this.grabbed.weight) * br;
                this.length -= s;
                if (this.length <= 20) { this.reset(); finished = true; }
            }
            return finished;
        }
        checkCollision() {
            const tx = this.x + Math.cos(this.angle) * this.length;
            const ty = this.y + Math.sin(this.angle) * this.length;
            const hr = 5 * game.buffs.hookSize;
            for (let i of game.entities.items) {
                if (Math.hypot(tx - i.x, ty - i.y) < i.radius + hr) {
                    this.state = 'RETRACT'; this.grabbed = i;
                    game.entities.items = game.entities.items.filter(it => it !== i);
                    return;
                }
            }
        }
        checkBoundaries() {
            const tx = this.x + Math.cos(this.angle) * this.length;
            const ty = this.y + Math.sin(this.angle) * this.length;
            return (tx < 0 || tx > CONFIG.width || ty > CONFIG.height);
        }
        reset() {
            this.length = 20; this.state = 'SWING';
            if (this.grabbed) {
                let dmg = this.grabbed.data.val;
                if (game.buffs.mineralDmg[this.grabbed.type]) dmg *= game.buffs.mineralDmg[this.grabbed.type];
                game.score += dmg;
                const isCrit = Math.random() < (game.buffs.critChance || 0.15);
                if (isCrit) {
                    dmg = Math.floor(dmg * 1.5);
                    game.turnAction = { type: 'CRIT', mineral: this.grabbed.data.name, damage: dmg };
                    game.entities.monsters.forEach(m => m.takeDamage(dmg, this.grabbed.type, true));
                } else {
                    const targets = game.entities.monsters.filter(m => !m.dead);
                    if (targets.length > 0) {
                        const t = targets[Math.floor(Math.random() * targets.length)];
                        t.takeDamage(dmg, this.grabbed.type, false);
                        game.turnAction = { type: 'HIT', mineral: this.grabbed.data.name, damage: dmg };
                    } else {
                        game.turnAction = { type: 'HIT', mineral: this.grabbed.data.name, damage: 0 };
                    }
                }
                this.grabbed = null; game.updateUI();
            } else { game.turnAction = { type: 'MISS' }; }
            if (game.hooks.length > 1 && game.hooks.every(h => h.state === 'SWING')) {
                const h = game.hooks[0]; h.x = CONFIG.width/2; game.hooks = [h];
            }
        }
        draw(ctx) {
            const tx = this.x + Math.cos(this.angle) * this.length;
            const ty = this.y + Math.sin(this.angle) * this.length;
            ctx.lineWidth = 3; ctx.strokeStyle = '#aaa';
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(tx, ty); ctx.stroke();
            const s = 10 * game.buffs.hookSize;
            ctx.save(); ctx.translate(tx, ty); ctx.rotate(this.angle - Math.PI/2);
            ctx.beginPath(); ctx.arc(0, 0, s, 0, Math.PI); ctx.stroke();
            if (this.grabbed) { ctx.rotate(-(this.angle - Math.PI/2)); ctx.translate(0, 15); this.grabbed.x=0; this.grabbed.y=0; this.grabbed.draw(ctx); }
            ctx.restore(); ctx.fillStyle = '#f39c12'; ctx.beginPath(); ctx.arc(this.x, this.y, 15, 0, Math.PI*2); ctx.fill();
        }
    }

    class Mineral {
        constructor(t, x, y) {
            this.type = t; this.data = MINERALS[t]; this.x = x; this.y = y;
            const sm = game.buffs.mineralSize[t] || 1.0;
            this.radius = this.data.radius * sm;
            this.weight = this.data.weight * (sm>1?1.2:(sm<1?0.8:1.0));
        }
        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y);
            ctx.font = `${this.radius * 1.2}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 5;
            ctx.fillText(this.data.icon, 0, 0); ctx.restore();
        }
    }

    class Monster {
        constructor(t, x, y, l) {
            this.type = t; this.x = x; this.y = y;
            let b = (t === 'BOSS') ? 2500 : 300; let s = (t === 'BOSS') ? 1.4 : 1.1;
            this.maxHp = Math.floor(b * Math.pow(s, Math.floor(l/5))); this.hp = this.maxHp;
            this.dead = false; this.status = { poison: 0, bleed: 0 };
        }
        processTurn() {
            if (this.dead) return;
            let dot = 0;
            if (this.status.poison > 0) { dot += Math.ceil(this.maxHp * 0.02 * this.status.poison); this.status.poison--; }
            if (this.status.bleed > 0) { dot += 50 * this.status.bleed; this.status.bleed--; }
            if (dot > 0) {
                this.hp -= dot; game.entities.damageTexts.push(new DamageText(`-${dot}`, this.x, this.y-20, "#aaa"));
                if (this.hp <= 0) { this.hp = 0; this.dead = true; }
                if (this.type === 'BOSS') game.updateUI();
            }
        }
        takeDamage(d, src, crit) {
            const eff = game.buffs.mineralEffect[src];
            if (eff === 'POISON') { this.status.poison++; game.entities.damageTexts.push(new DamageText("ä¸­æ¯’", this.x, this.y-40, "#2ecc71")); }
            if (eff === 'BLEED') { this.status.bleed++; game.entities.damageTexts.push(new DamageText("æµè¡€", this.x, this.y-40, "#c0392b")); }
            this.hp -= d;
            const c = crit ? "#f1c40f" : "#fff"; const sz = crit ? 30 : 20;
            game.entities.damageTexts.push(new DamageText(d, this.x, this.y, c, sz));
            if (this.hp <= 0) { this.hp = 0; this.dead = true; }
            if (this.type === 'BOSS') game.updateUI();
        }
        draw(ctx) {
            if (this.dead) return;
            const off = Math.sin(Date.now()/300) * 5; ctx.save(); ctx.translate(this.x, this.y + off);
            if (this.status.poison > 0) ctx.fillStyle = '#2ecc71'; else if (this.status.bleed > 0) ctx.fillStyle = '#e74c3c';
            else ctx.fillStyle = (this.type === 'BOSS') ? '#8e44ad' : ((this.type === 'SLIME')?'#27ae60':'#7f8c8d');
            
            if(this.type==='BOSS'){ ctx.scale(2,2); ctx.beginPath(); ctx.moveTo(0,-20); ctx.lineTo(15,0); ctx.lineTo(10,20); ctx.lineTo(-10,20); ctx.lineTo(-15,0); ctx.fill(); }
            else { ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill(); }
            
            ctx.fillStyle='#fff'; ctx.font='bold 12px Arial'; ctx.textAlign='center';
            if(this.type!=='BOSS') {
                ctx.fillText(`${this.hp}`, 0, -30);
                ctx.fillStyle='black'; ctx.fillRect(-20,30,40,5); ctx.fillStyle='red'; ctx.fillRect(-20,30,40*(this.hp/this.maxHp),5);
            } else { ctx.fillText(`${this.hp}`, 0, -30); }
            ctx.restore();
        }
    }

    class DamageText {
        constructor(t, x, y, c, s=20) { this.t = t; this.x = x; this.y = y; this.c = c; this.s = s; this.l = 1.0; }
        update() { this.y -= 0.8; this.l -= 0.02; }
        draw(ctx) { ctx.save(); ctx.globalAlpha = Math.max(0, this.l); ctx.fillStyle = this.c; ctx.font = `bold ${this.s}px Arial`; ctx.fillText(this.t, this.x, this.y); ctx.restore(); }
    }

    const CardGenerator = {
        generate(type, game) {
            if (type === 'LEGENDARY') {
                const list = [
                    { name: 'é›™é‡æ›é‰¤', desc: 'æ¶ˆè€—1æ¬¡ï¼Œå°„å‡º2é‰¤', icon: 'ğŸ”±', apply: g => g.buffs.doubleHook = true },
                    { name: 'å¹¸é‹å›æ”¶', desc: '30% æ©Ÿç‡å…è€—', icon: 'ğŸ€', apply: g => g.buffs.freeHookChance += 0.3 },
                    { name: 'è±é¥’è™Ÿè§’', desc: 'ç¤¦ç‰© +5', icon: 'ğŸŒ½', apply: g => g.buffs.extraMineralCount += 5 },
                    { name: 'æœƒå¿ƒä¸€æ“Š', desc: 'çˆ†æ“Š +20%', icon: 'ğŸ¯', apply: g => g.buffs.critChance += 0.2 }
                ]; return list[Math.floor(Math.random()*list.length)];
            } else if (type === 'HOOK') {
                const list = [
                    { name: 'æ“´å……å½ˆåŒ£', desc: 'æœ€å¤§æ¬¡æ•¸ +5', icon: 'ğŸ’', apply: g => g.maxHookCount += 5 },
                    { name: 'å·¨å‹é‰¤çˆª', desc: 'ç¯„åœ +50%', icon: 'ğŸª', apply: g => g.buffs.hookSize += 0.5 },
                    { name: 'æ¶²å£“é¦¬é”', desc: 'é€Ÿåº¦ +20%', icon: 'âš™ï¸', apply: g => g.buffs.hookSpeed *= 1.2 }
                ]; return list[Math.floor(Math.random()*list.length)];
            } else {
                let valid = Array.from(game.discoveredMinerals);
                if (valid.length === 0) valid = ['ROCK', 'COPPER'];
                const t = valid[Math.floor(Math.random()*valid.length)];
                const name = MINERALS[t].name;
                const effects = [
                    { s: 'æ·¬æ¯’', d: 'ä¸­æ¯’', c: 'POISON', i: 'ğŸ§ª' }, { s: 'é‹¸é½’', d: 'æµè¡€', c: 'BLEED', i: 'ğŸ©¸' },
                    { s: 'é‡æ“Š', d: 'å‚·+100%', c: 'DMG', i: 'ğŸ’¥' }, { s: 'ç¤¦è„ˆ', d: 'å‡ºç¾UP', c: 'SPAWN', i: 'ğŸ“ˆ' },
                    { s: 'å·¨å‹', d: 'è®Šå¤§', c: 'SZ_UP', i: 'â«' }, { s: 'æ¯ç«­', d: 'å‡ºç¾DOWN', c: 'SPAWN_DN', i: 'ğŸ“‰' }
                ];
                const eff = effects[Math.floor(Math.random()*effects.length)];
                return {
                    name: `${name}${eff.s}`, desc: eff.d, icon: eff.i,
                    apply: g => {
                        if(eff.c==='DMG') g.buffs.mineralDmg[t]=(g.buffs.mineralDmg[t]||1)+1;
                        else if(eff.c==='SPAWN') g.buffs.spawnRates[t]=(g.buffs.spawnRates[t]||1)+2;
                        else if(eff.c==='SPAWN_DN') g.buffs.spawnRates[t]=(g.buffs.spawnRates[t]||1)*0.2;
                        else if(eff.c==='SZ_UP') g.buffs.mineralSize[t]=(g.buffs.mineralSize[t]||1)*1.5;
                        else if(eff.c==='SZ_DN') g.buffs.mineralSize[t]=(g.buffs.mineralSize[t]||1)*0.6;
                        else g.buffs.mineralEffect[t]=eff.c;
                    }
                };
            }
        }
    };

    const game = new Game();
    window.addEventListener('keydown', e => { if(e.code==='Space'||e.code==='ArrowDown') game.handleInput(); });
    document.getElementById('gameCanvas').addEventListener('mousedown', () => game.handleInput());
    document.getElementById('gameCanvas').addEventListener('touchstart', e => { e.preventDefault(); game.handleInput(); });

</script>
</body>
</html>
